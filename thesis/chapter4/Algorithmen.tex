% UTF-8

% single-chapter commands
\documentclass[../main/thesis.tex]{subfiles}
\onlyinsubfile{\setcounter{chapter}{3}}  % single-chapter command
\begin{document}


\chapter{Algorithmen zur Generalisierung}

\section{Vorüberlegungen}

% Erst über Generalisierung nachgedacht, da sie das schwierigerer Problem zu sein schien (in der Erwartung, die Identifikation ließe sich evtl. "nebenbei" lösen).
% Die Generalisierung ist auf den allerersten Blick ein einfaches geometrisches Problem, das keiner ausgefeilten Algorithmen a la 2.5 bedarf. Erst mal probiert, ob es sich so lösen lässt. Später festgestellt (-> Implementierung?), dass es in der Tat nicht so schrecklich schwierig war, jedoch die Entscheidung, was zusammengehört und was nicht, im Allgemeinen Fall schwieriger als erwartet war (ein Problem, das allerdings wohl auch für die Lösungen aus 2.5 bestanden hätte, womöglich gar in verstärktem Ausmaß).

% damals sehr früh (noch vor Anmeldung) den Algorithmus in groben Zügen aufgestellt und implementiert
% Vorgehen war im Prinzip, das Problem graphisch/geometrisch anzugehen und auf Papier zu lösen, dann in Code zu übertragen
% anschließend nur noch (sehr umfangreiche) Verbessserungen vorgenommen, insbesondere zur Flexibilisierung (individuellere Analyse, unterschiedliche Testdaten, Spezialfälle)
% zeitaufwändig: Alg. implementieren; insb.: Probleme im Workflow lösen (z. B. I/O), OOP, die Details des Alg. so hinbekommen, dass er halbwegs "rund" läuft, Probleme wie bei Kreuzungen
% habe versucht, ein wenig Test-Driven Development zu lernen, was mir schwer fiel, weil ich ständig die Struktur änderte
% erst versucht, rein geometrisch zu arbeiten, dann festgestellt (mit Jochen), dass bei Autobahnen etc Tags idR passen und die Sache erleichtern

% an dieser Stelle außerdem big picture: wie hängen die folgenden teile zusammen?
% -> lt. Themenblatt soll das Analyseergebnis auch separat von der Generalisierung zu verwenden sein!
% d.h. die Main-Klasse / Fassade sollte gar nicht hier beschrieben werden, das ist ein Implementierungsdetail (unter Kap. 5 zu beschrieben, wozu aber Kap. 5 wohl etwas umorganisiert werden müsste)
% anstatt des Analyser-Outputs ist tatsächlich bisher der CorrelationGraph das Analyseergebnis, jedoch noch unvollständig (man bräuchte noch eine Art Metrik, dass z. B. ab 80% parallelen Segmenten zwei Ways als parallel gelten; evtl. auch einen Append-Schritt, denn zur (verlangten) Identifikation paralleler Linienzüge müssten diese erst mal aus den Ways erzeugt werden, falls die Ways nicht ausreichen)

% im CLI sieht's im Moment in etwa so aus:
% 1. create OsmDataset (als InputDataset-Instanz, via ShapeReader)
% 2. Combiner.run
% 3. output
% also eigentlich nichts, was algorithmisch einer besonderen Beschreibung bedarf

% an dieser Stelle außerdem __Überleitung__: was kann man aus 2.5 für lehren/erkenntnisse ziehen? irgendwas anwendbares dabei? wenn ja, warum nicht?

Aus der Menge der zuvor erwähnten bereits existierenden Ansätze hebt sich zunächst die Skelettierung heraus, indem es für sie bereits mehrere funktionale Implementierungen der Zusammenfassung gibt (Abschnitt~\ref{ch:skeleton}).
Diese haben jedoch laut der Autoren alle mit erheblichen Problemen in Kreuzungsbereichen zu kämpfen, die nur teilweise automatisiert gelöst werden können.
Dieser Ansatz erscheint wenig vielversprechend.
% weil?

Letzteres gilt auch für den in Abschnitt~\ref{ch:conflict-detection} diskutierten Ansatz zur Konflikterkennung.
Zwar wäre eine Kombination mit anderen Ansätzen denkbar.
So könnte möglicherweise eine Pufferung der Linienzüge mit anschließender Verschneidung der entstehenden Flächen Informationen über die Linienzüge liefern:
Dort, wo sich Schnittflächen bilden, bestehen Konflikte;
Konflikte zwischen zwei Linien über große Teile ihrer Länge hinweg wären ein Indiz für Parallelität.
Dies löst jedoch nicht das Problem der Zusammenfassung beider Linien (vgl. Abschnitte~\ref{ch:buffer} und~\ref{ch:skeleton}).

Interessanter erscheint der bereits in Abschnitt~\ref{ch:graph-based} erwähnte Gedanke, dass Straßen mit parallelen Richtungsfahrbahnen oft komplex modellierte Kreuzungen haben.
Können diese zu jeweils einzelnen Knoten generalisiert werden, dann sind die parallelen Richtungsfahrbahnen im Graphen des Straßennetzes zwei gegenläufige gerichtete Kanten.
Anschließend wäre die geometrische Zusammenfassung dieser Kanten möglicherweise einfach.

% "perceptual grouping": nicht vielversprechend

Der von Thom beschriebene Ansatz zur Generalisierung der OS~MasterMap klingt vielversprechend (Abschnitt~\ref{os-mastermap}).
Er kombiniert Ideen aus der visuellen Wahrnehmung \term{(strokes)} und der Graphenanalyse, um Richtungsfahrbahnen zusammenzufassen.
Den Erfolg seiner Methode schreibt er jedoch unter anderem der gründlichen Klassifikation seiner Ausgangsdaten nach Bauart der Straße zu (einbahnig/zweibahnig usw.). \cf[14]{Tho05}
Diese existiert in dieser Form nicht in OpenStreetMap, so dass seine Methode nicht direkt übertragbar erscheint.

Zwar kann für Autobahnen davon ausgegangen werden, dass sie zweibahnig ausgebaut sind.
Seltene Ausnahmen wie etwa die Bundesautobahn~62 zwischen Landstuhl und Pirmasens sollten, wenn sie denn tatsächlich als \osmtag{highway}[motorway] eingetragen sind, das Attribut \osmtag{oneway}[no] tragen und sich so identifizieren lassen.
Im übrigen Straßennetz sind solche Aussagen auf Basis der \osm-Daten jedoch nicht möglich.

Es ist ohnehin fraglich, wie stark die von Thom eingesetzte Erkennung von \term{strokes} als möglichst \emph{lange} Linienzüge die Generalisierung im Kontext von \osm\ tatsächlich vereinfachen würde.
Zwar sind die einzelnen \term{ways} in \osm\ wegen ihrer ungleichmäßigen Aufteilung oft nicht gut zur Weiterverarbeitung geeignet.
Allerdings wären zur Prüfung auf Parallelität und zur Zusammenfassung auf eine gemeinsame Mittellinie auch möglichst \emph{kurze} Linienfragmente gut geeignet, sofern die Fragmentierung beider Parallelen gleichmäßig ist.

Im folgenden Abschnitt~\ref{ch:algorithm-principle} wird in allgemeinen Begriffen beschrieben, wie parallele Linienzüge auf Basis einer solchen gleichmäßigen Fragmentierung zusammengefasst werden können.
Im Anschluss daran folgt die formale Beschreibung dieser Algorithmen.

% erst Grundprinzip / -idee / -ansatz beschreiben, dann Edge Cases

\section{Grundprinzip}
\label{ch:algorithm-principle}

Um das Zusammenfassen paralleler Linienzüge vorzubereiten, werden alle \term{nodes} des einen Linienzugs jeweils einem gegenüberliegenden \term{node} auf dem parallelen Linienzug zugeordnet.
Die Verbindung der Mittelpunkte zwischen den so einander zugeordneten \term{nodes} ergibt direkt den zusammengefassten Linienzug als Ergebnis der Generalisierung (Abbildung~\ref{fig:general-approach}).

Dieses Vorgehen vermeidet, dass die in Abschnitt~\ref{osm-fragmentation} besprochene häufige ungleichmäßige Fragmentierung von \osm-Linienzügen in mehrere \term{ways} einen Einfluss auf den Generalisierungsvorgang hat.
Aufgrund der nicht immer gleichen Anzahl und Verteilung der \term{nodes} kommt es vor, dass ein \term{node} des einen Linienzugs mehreren \term{nodes} des anderen Linienzugs zugeordnet wird, was jedoch unproblematisch ist.

\twofigures{ht}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/general-approach}
	\caption{Linienzusammenfassung durch Mittelpunktbildung nach Zuordnung gegenüberliegender \term{nodes}}
	\label{fig:general-approach}
}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/motorway-fragments}
	\caption{ungleichmäßige Fragmentierung paralleler Linienzüge (Beispiel)}
	\label{fig:motorway-fragments}
}

Um zwei gegenüberliegende \term{nodes} einander zuordnen zu können, müssen zunächst die Linien, deren Teil sie sind, als zueinander parallel erkannt werden.
Auch hierbei ist die erwähnte ungleichmäßige Fragmentierung in bestimmten Fällen problematisch.
Beispielsweise müssten die einzelnen \term{ways} in Abbildung~\ref{fig:motorway-fragments}, aus denen die beiden dargestellten Parallelen bestehen, zunächst zu einem längeren Linienzug verknüpft werden, um einen Vergleich zu ermöglichen.
Dies entspräche dem in Abschnitt~\ref{os-mastermap} beschriebenen Ansatz von Thom, der damit zufriedenstellende Resultate erzielte, dabei jedoch die hohe Qualität seiner Ausgangsdaten betonte, welche bei wie für \osm\ von Freiwilligen erfassten Geodaten nicht vorausgesetzt werden kann.
% lässt sich diese aussage belegen?

Um diese Problematik zu umgehen, verwendet das in dieser Arbeit vorgestellte Verfahren möglichst \emph{kurze} Liniensegmente anstelle möglichst \emph{langer} Linienzüge.
Die Verbindung zweier benachbarter \term{nodes} in einem \term{way} als kürzestmögliche lineare Einheit in den \osm-Ausgangsdaten (früher als \term{segment} bezeichnet \cf[57]{RT09}) ist allerdings für einen Vergleich nicht viel besser geeignet als der vollständige \term{way}%
% warum nicht? (wenig spezifisch formuliert)
, wie aus Abbildung~\ref{fig:motorway-fragments} ersichtlich ist.
% nicht wirklich gut ersichtlich; neue Abbildung mit Pfeilen wie in fig:comparable-fragments?
Daher werden die \term{segments} vor der Analyse auf Parallelität solange immer weiter unterteilt, bis schließlich ein einfacher geometrischer Vergleich möglich ist (Abbildung~\ref{fig:comparable-fragments}).

\onefigure{ht}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/comparable-fragments}
	\caption{Herstellung einer gleichmäßigen Fragmentierung paralleler Linienzüge}
	\label{fig:comparable-fragments}
}



\section{Operationen}
\label{ch:algorithm-parts}

Der zuvor beschriebene Lösungsansatz lässt sich vereinfacht als Sequenz von vier Operationen ausdrücken:
\begin{enumerate}[nosep]
	\item Segmente unterteilen
	\item Analysieren
	\item Punktezuordnung
	\item Parallelen zusammenfassen
\end{enumerate}
%
% Datenflussdiagramm
%
Die folgenden Abschnitte beschreiben jede dieser Operationen im Detail.

% Zur Vereinfachung Vorbedingungen der Eingabedaten: ...

% Definitionen: Ways haben Nodes; Segmente haben exakt zwei Nodes, welche mit folgender "Funktion zu erhalten sind; ...


\subsection{Segmente unterteilen}
\label{ch:split-algorithm}

In \osm-Daten sind seit Oktober~2007 Segmente (Verbindungen von exakt zwei \term{nodes}) nicht mehr als eigene Objekte enthalten \cf[57]{RT09}.
Anhand der aus der Datenquelle eingelesenen Menge aller \term{ways} wird daher zunächst durch \textproc{Segmentierung} die Menge aller Segmente ermittelt (Abbildung~\ref{fig:segments-in-way}).

\onefigure{ht}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/segments-in-way}
	\caption{vier Segmente in einem \term{way} (Beispiel)}
	\label{fig:segments-in-way}
}
\onefigure{!ht}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/vector-geometry}
	\caption{einfache Vektorgeometrie an einem Segment demonstriert}
	\label{fig:vector-geometry}
}

Um Verbindungen zwischen zwei \term{nodes} deterministisch beschreiben zu können, werden diese hier als Kanten in einem gerichteten Graphen betrachtet.
Die beiden \term{nodes} werden als \textproc{Start} und \textproc{Ende} bezeichnet.
% evtl. besser \textproc{Ziel}, um Oberbegriff "Endpunkt" freizuhalten

Geometrisch betrachtet entsprechen \term{nodes} Punkten, die durch vom Koordinatenursprung ausgehende Vektoren in der euklidischen Ebene definiert sind.
Segmente als gerichtete Verbindungen zweier solcher Punkte lassen sich dann ebenfalls als Vektoren auffassen und als geordnetes Paar notieren.

So könnten beispielsweise die Punkte $a$ und $b$ das Segment $(a,b)$ definieren, welches geometrisch zum Vektor $b - a$ kongruent wäre (Abbildung~\ref{fig:vector-geometry}).

\begin{algorithmhere}{Segmentierung}
\label{alg:Segmentierung}
\begin{algorithmic}
\Function{Segmentierung}{$W$}\Comment{Menge aller \term{ways} $W$}
	\State $S \gets \varnothing$
	\ForAll{$w \textbf{ mit } w \in W $}
%		\State $N \gets$ alle \term{nodes} von $w$
%		\ForAll{$i \textbf{ mit } i \in \mathbb{N} : 0 < i < |N| $}\Comment{alle \term{nodes} außer dem ersten}
%			\State $n \gets$ \term{node} $i$ aus $N$
%			\State \textbf{füge} neues Segment ... \textbf{zu} $S$ \textbf{hinzu}
%		\ForAll{$n$ \textbf{mit} $n \in N \wedge \exists$ $m : m$ ist Vorgänger von $n$}
		\ForAll{$n$ \textbf{mit} $n \in w.nodes \wedge \exists\ m : m$ ist Vorgänger von $n$ in $w$}
%			\State \textbf{füge} neues Segment $(m, n)$ \textbf{zu} $S$ \textbf{hinzu}
			\State $S \gets S \cup \{(m,n)\}$\Comment{neues Segment $(m, n)$ zu $S$ hinzufügen}
		\EndFor
	\EndFor
	\State \textbf{Ergebnis} $S$
\EndFunction
\end{algorithmic}
\end{algorithmhere}
% implementiert in OsmWay.segmentation()

% "anschließend" ergibt einen etwas holprigen Übergang

Die Segmente werden anschließend durch \textproc{Splitten} derart aufgeteilt, dass ein geometrischer Vergleich leicht möglich wird (Abbildung~\ref{fig:comparable-fragments}).
Die so entstehenden Fragmente sind keine Segmente im Sinne der früheren gleichnamigen \osm-Objekte, da der Punkt, an dem sie zerteilt wurden, keinen \term{node} in OpenStreetMap darstellt.
Im Folgenden werden sie dennoch vereinfachend Segmenten gleichgestellt, da sie ansonsten dieselben Eigenschaften besitzen.

Aufgeteilt werden Segmente jeweils am \textproc{Fußpunkt} eines Lots, das von einem \term{node} eines anderen Segments gefällt wird.
Der gewählte Algorithmus für das \textproc{Splitten} arbeitet geometrisch rekursiv:
Alle erzeugten Fragmente werden wieder zur Menge der Segmente hinzugefügt und somit immer weiter aufgeteilt, bis kein \textproc{Fußpunkt} mehr gefunden wird.

% TODO: Grafik (unbedingt!), um "rekursiv" zu illustrieren

\begin{algorithmhere}{Splitten}
\label{alg:Splitten}
\begin{algorithmic}
\State $\textbf{Variable } wurzel : Segment \rightarrow Segment$
\State $\textbf{Anfangswert } wurzel(s) \eqdef s\;\forall\ s$
\Function{Splitten}{$S$}\Comment{Menge aller Segmente $S$}
	\State $S' \gets S$
	\ForAll{$s \textbf{ mit } s \in S'$}
		\ForAll{$n \textbf{ mit } n \in \{\textproc{Start}(s), \textproc{Ende}(s)\} $}
			\State $T \gets \textproc{NaheSegmente}(s, S')$
			\ForAll{$t \textbf{ mit } t \in T \wedge \exists\ f : f = \textproc{Fußpunkt}(n, t)$}
				\State $t_1 \gets (\textproc{Start}(t), f)$
				\State $t_2 \gets (f, \textproc{Ende}(t))$
				\State $S' \gets \{t_1, t_2\} \cup S' \setminus \{t\}$\Comment{$t$ ersetzen durch Fragmente $t_1$ und $t_2$}
				\State $wurzel(t_1) \gets wurzel(t)$
				\State $wurzel(t_2) \gets wurzel(t)$
			\EndFor
		\EndFor
	\EndFor
	\State \textbf{Ergebnis} $S'$
\EndFunction
\end{algorithmic}
\end{algorithmhere}
% implementiert in Combiner.splitSegments()

Es ist nicht notwendig, jedes Segment mit allen anderen Segmenten zu vergleichen.
Segmente, die zu weit entfernt und somit nicht \textproc{NaheSegmente} sind, können von vornherein als potenzielle Parallelen ausgeschlossen werden.
Zur Entscheidung, welche Segmente als „nah“ gelten und damit für Parallelität in Frage kommen, wird für jedes Segment eine \textproc{Hülle} gebildet, welche etwas größer als das jeweilige Segment ist, so dass sich die Hüllen von nahe beieinander liegenden Segmenten überschneiden.
% TODO: Grafik und/oder Literaturverweis

%2. Regionalisierung
%- ∀ Segmente : Liste der "nahen" anderen Segmente
%→ Spatial Index / Array (sortiert)

\begin{algorithmhere}{nahe Segmente}
\label{alg:NaheSegmente}
\begin{algorithmic}
\Function{NaheSegmente}{$s, S$}\Comment{Menge aller Segmente $S$}
	\State \textbf{Ergebnis} $\{t : t \in S \wedge \textproc{Hülle}(s) \cap \textproc{Hülle}(t) \neq \varnothing\}$
\EndFunction
\end{algorithmic}
\end{algorithmhere}
% implementiert in Combiner.regionaliseSegments()
% abweichend wird dort das Ergebnis für alle s berechnet und gecached

% TODO: Diese Definition weicht vereinfachend vom ursprünglichen Entwurf ab,
% indem alle nahen Segmente geliefert werden statt nur solche, die gleich
% ausgerichtet sind (closeSegments/closeParallels). Tests zeigen, dass diese
% Vereinfachung unzulässig ist: Das Ergebnis wird verschlechtert, weil so
% halt gerade an Kreuzungen und Querungen lauter Splits entstehen, die kein
% Mensch braucht, was die Analyse erschwert (und sicher auch ineffizient
% ist). NAHESEGMENTE muss entweder entsprechend korrigiert oder aber die
% Beschreibung entsprechend ergänzt werden. Außerdem liefert diese Definition
% fälschlich auch "s" selbst zurück, was sich allerdings durch ein einfaches
% "\wedge s \neq t" lösen lässt.

Als \textproc{Hülle} könnte ein Puffer dienen.
Aus Gründen der Effizienz bietet es sich jedoch an, die \textproc{Hülle} rechteckig im Koordinatennetz anzulegen.
Für diesen Fall hängt die Größe der Hülle auch von der Orientierung des Segments ab.
Im Ergebnis wird dann später zu sehen sein, dass diagonal zum Koordinatennetz ausgerichtete Segmente bei größeren Abständen zueinander als parallel erkannt werden als solche Segmente, die orthogonal zum Koordinatennetz ausgerichtet sind.

Weiterhin hängen diese Erkennungsabstände vom gewählten Koordinatennetz ab.
Wird beispielsweise mit geographischen Koordinaten gearbeitet, variiert das Verhältnis der Erkennungsabstände in Ost/West- und in Nord/Süd-Richtung mit der geographischen Breite.
Insbesondere auf höheren Breiten bietet sich daher der Einsatz einer winkeltreuen Abbildung wie etwa Gauß-Krüger an, um diese Einflüsse zu minimieren.

Um die Korrektheit der Algorithmen sicherzustellen, ist aus diesen Gründen in der späteren \textproc{Analyse} auf Parallelität eine erneute Prüfung des tatsächlichen Abstands zweier zu vergleichender Segmente notwendig.
Diese kann dann jedoch auf \textproc{NaheSegmente} beschränkt werden und ist dementsprechend billig (vergleiche Abschnitt~\ref{ch:analyse-algorithm}).

% TODO: Grafik?

\begin{algorithmhere}{Definition der erweiterten Hüllfunktion für \textproc{NaheSegmente}}
\label{alg:Huelle}
\begin{algorithmic}
\Function{Hülle}{$s$}
	\State \textbf{Ergebnis} sei die nach allen Kardinalrichtungen um $\eta/2$ vergrößerte rechteckige Hülle um das Segment $s$, wobei $\eta$ der festzulegende Höchstabstand sei, für den zwei Segmente als „nahe“ gelten dürfen.
\EndFunction
\end{algorithmic}
\end{algorithmhere}
% implementiert in LineSegment.envelope()

%3. Orientierungs-Ausschluss
%- ∀ Segmente : Liste der "nahen und geometrisch parallelen" Segmente

%...

%4. Splitten ("re-entrant") in Fragmente
%Liste B aller `LinePart` als Basis (initial: alle `LineSegment`)
%- _∀ B : P₁, P₂_
%    - _∀ P_ als p
%        - _∀ `splitTargets()`_ : (_target noch nicht gesplittet_ -> next;)
%            - Fußpunkt PF für p auf target suchen
%            - falls nicht außerhalb target (✐) / falls ≠ target.P₁, target.P₂: *Split* target bei PF
%                - neue Fragmente f₁, f₂ mit P₁–PF und PF–P₂ erzeugen
%                - beide f₁, f₂ an Controller melden (für Basis-Iterator: hinten anhängen an Liste zu splittender Segmente)
%                - Basis und target als gesplittet / "fertig" markieren
%                - … mehr an Controller melden…?
%(`splitTargets()`: Liste der "nahen" anderen Segmente)

\noindent
Das Aufteilen in Fragmente erfolgt jeweils am \textproc{Fußpunkt}~(Abbildung~\ref{fig:footpoint}).

\begin{algorithmhere}{Fußpunkt}
\label{alg:Fusspunkt}
\begin{algorithmic}
\Function{Fußpunkt}{$n,t$}
%	\State Es sei $l \bot t$ und $n \in l$. Dann sei $f \coloneq l \cap t$ bei $min(||f-t_1||, ||f-t_2||) > \varepsilon$ $\wedge$ $max(||f-t_1||, ||f-t_2||) < ||t||$, wobei $\varepsilon$ die festzulegende Mindestlänge eines Fragments sei.
	\State \textbf{Ergebnis} sei der Lotfußpunkt~$f$ des Punkts~$n$ auf der Geraden~$t$. Liegt~$f$ nicht zwischen den Punkten $\textproc{Start}(t)$ und $\textproc{Ende}(t)$ oder liegt~$f$ näher an $\textproc{Start}(t)$ oder $\textproc{Ende}(t)$ als die festzulegende Mindestlänge~$\mu$ eines Fragments, dann gibt es kein Ergebnis.
% Der zweite Satz ist ein wesentliches, aber nicht unbedingt offensichtliches Detail, deshalb sollte auch das an sich einfache Konzept "Lotfußpunkt" formal beschrieben werden.
\EndFunction
\end{algorithmic}
\end{algorithmhere}
% implementiert in AbstractLinePart.findPerpendicularFoot()

\onefigure{H}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/footpoint}
	\caption{Bestimmung des Punkts, an dem ein Segment aufzuteilen ist}
	\label{fig:footpoint}
}
% TODO: Abbildung verbessern: Segment s sollte enthalten sein + einheitliches Design

\subsection{Analysieren}
\label{ch:analyse-algorithm}

Das Ergebnis der Operation „Segmente unterteilen“ eignet sich zur \textproc{Analyse} auf Parallelität.
Hierfür werden Geometrie und Attribute näher verglichen mit dem Ziel, für jedes Segment beidseitig entweder genau ein oder kein anderes Segment als „parallel“ zu kennzeichnen.
% (dies funktioniert, weil bei ungleichmäßiger Fragmentierung die Verknüpfung über das _andere_ Segment hergestellt wird, d. h. dies ergibt keine 1:1-Beziehung)
%
Die Unterscheidung der Seiten links und rechts kann durch Bestimmung der Winkel zu den \term{nodes} des jeweils anderen Segments erfolgen (Abbildung~\ref{fig:left-side}).

\onefigure{ht}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/left-side}
	\caption{Erkennen einer nahen Parallele auf der linken Seite eines Segments}
	\label{fig:left-side}
}

%5. Analyse der Fragmente
%∀ Fragmente:
%- Ähnlichkeitsmaß zu allen anderen in Frage kommenden Fragmenten bestimmen (⇐ `closeParallels`), sortieren
%- aussortieren über `Analyser`
%- ∀ verbleibenden anderen Fragmente: best match(es) L+R finden, falls vorhanden (teilen 2 Segmente einen Node, ist es kein Match! (sonst klappt die L/R-Punktfindung nicht richtig)
%- best match(es) für _Segmente_ eintragen in eine Liste (und zwar reziprok) (→ eigentlich unnötig??) (∀ Segmente: ∃ 2 Listen "paralleler" Segmente) L+R (|||)

\begin{algorithmhere}{Analyse}
\label{alg:Analyse}
\begin{algorithmic}
\State $\textbf{Variable } parallelLinks : Segment \rightarrow Segment$
\State $\textbf{Anfangswert } parallelLinks(s) \eqdef \varnothing\ \forall\ s$
\State $\textbf{Variable } parallelRechts : Segment \rightarrow Segment$
\State $\textbf{Anfangswert } parallelRechts(s) \eqdef \varnothing\ \forall\ s$
\Function{Analyse}{$S$}\Comment{Menge aller \emph{unterteilten} Segmente $S$}
	\ForAll{$s \textbf{ mit } s \in S$}
%		\State $T \gets \{t : wurzel(t) \in \textproc{NaheSegmente}(wurzel(s), S)\} \wedge \textproc{Parallel}(s, t)$  % exakt wie implementiert, aber eigentlich in dieser Form hier nicht nötig
		\State $T \gets \{t : t \in \textproc{NaheSegmente}(s, S) \wedge \textproc{Parallel}(s, t)\}$  % vereinfachend
		\State $v_{Start} \gets \textproc{Start}(t) - \textproc{Start}(s)$
		\State $v_{Ende} \gets \textproc{Ende}(t) - \textproc{Start}(s)$
		\State $L \gets \{t : t \in T \wedge \sphericalangle (s, v_{Start}) < 0 \wedge \sphericalangle (s, v_{Ende}) < 0\}$
		\State $R \gets \{t : t \in T \wedge \sphericalangle (s, v_{Start}) > 0 \wedge \sphericalangle (s, v_{Ende}) > 0\}$
		\State\Comment{Mengen $L, R$ aller nahen Parallelen links- bzw. rechtsseitig}
		\State\Comment{Winkel seien definiert im Intervall $(-\pi,\pi)$ und im Uhrzeigersinn}
		\ForAll{$l \textbf{ mit } l \in L$}
			\If{$0 < \textproc{Distanz}(s, l) \leqslant \textproc{Distanz}(s, l')\; \forall\ l' \in L$}
				\State $parallelLinks(wurzel(s)) \gets l$
			\EndIf
		\EndFor
		\ForAll{$r \textbf{ mit } r \in R$}
			\If{$0 < \textproc{Distanz}(s, r) \leqslant \textproc{Distanz}(s, r')\; \forall\ r' \in R$}
				\State $parallelRechts(wurzel(s)) \gets r$
			\EndIf
		\EndFor
	\EndFor
	\State \textbf{Ergebnis} $parallelLinks, parallelRechts$
\EndFunction
\end{algorithmic}
\end{algorithmhere}

% TODO: Weil Fragmente analysiert werden, ist es denkbar, dass mehrere verschiedene Segmente als "links parallel" markiert werden (was IIRC auch so implementiert wurde), diese Formulierung findet aber nur eine davon; spielt dies eine Rolle?

% reicht es evtl. aus festzulegen: 2 Segmente parallel gdw. mind. je ein Fragment parallel ist? dann wäre es danach nur noch eine frage, das "beste" zu finden
% oder evtl. statt "<- l" einfach "<- wurzel(l)" und dann das als Menge ausführen? Das könnte der tatsächlichen Implementierung am ehesten entsprechen, ist aber evtl. unnötig kompliziert.

Dabei kommen nur solche Segmente für die Kennzeichnung in Frage, die im Kontext des jeweiligen Anwendungsfalls als \textproc{Parallel} gelten (vergleiche Kapitel~3).

\begin{algorithmhere}{Parallel}
\label{alg:Parallel}
\begin{algorithmic}
\Function{Parallel}{$s_1, s_2$}
	\State Die Segmente $s_1$ und $s_2$ seien parallel genau dann, wenn sie:
	\begin{itemize}[nosep,leftmargin=3.5em]
		% [LineSegment.closeParallels]
		\item ähnlich ausgerichtet sind (z.~B. $\abs\sphericalangle (s_1, s_2)\abs < 15\degree$),
		% [MyAnalyser.shouldEvaluate]
		\item nahe beieinander liegen (z.~B. $\textproc{Distanz}(s_1, s_2) < \unit[40]{m}$),
		\item nicht so sehr zueinander versetzt sind, dass sie mehr hintereinander als nebeneinander liegen,  % "ignore collinear fragments"; sollte durch die geschickte Fragmentierung normal nicht vorkommen
		\item sich nicht überkreuzen,  % (sollte bereits durch \textproc{Analyse} ausgeschlossen sein)
		\item Teile von \term{ways} mit dem gleichen Wert für \osmtag{highway}[*] sind und
		\item Teile von \term{ways} mit dem gleichen Wert für \osmtag{ref}[*] sind.
	\end{itemize}
\EndFunction
\end{algorithmic}
\end{algorithmhere}

Dass die miteinander verglichenen Segmente nahe beieinander liegen, wird in der \textproc{Analyse} bereits durch die Beschränkung auf \textproc{NaheSegmente} sichergestellt.
Welche Segmente als „nah“ gelten, ist jedoch von der Definition der \textproc{Hülle} abhängig, für die Überlegungen zur Effizienz eine Rolle spielen (vergleiche Abschnitt~\ref{ch:split-algorithm}).
% daher in PARALLEL noch mal eine Abstands-Bedingung

% doppelt beschrieben -- was ist besser?

Aus der Menge aller als \textproc{Parallel} geltenden Segmente auf einer Seite wird das am nächsten gelegene als Parallele ausgewählt.
Auf welche Weise dazu die Distanz zwischen zwei Segmenten bestimmt wird, kann vom speziellen Anwendungsfall abhängen und soll hier nur beispielhaft angegeben werden.
So ist eine mögliche Metrik für die \textproc{Distanz} zweier Segmente der Abstand ihrer Mittelpunkte.

% tatsächlich implementiert: Summe der Abstände der jeweils nächsten Nodes (siehe MyAnalyser.evaluate)
% alternativ denkbar: _kleinster_ Abstand zweier Nodes

\begin{algorithmhere}{Beispielhafte Bestimmung der Distanz zweier Segmente}
\label{alg:Distanz}
\begin{algorithmic}
\Function{Distanz}{$s_1, s_2$}
%	\State \textbf{Ergebnis} $||\textproc{Mittelpunkt}(s_1) - \textproc{Mittelpunkt}(s_2)||$
	\State \textbf{Ergebnis} $\abs\textproc{Start}(s_1) - \textproc{Start}(s_2) + \textproc{Ende}(s_1) - \textproc{Ende}(s_2)\abs \cdot \frac{1}{2}$
\EndFunction
\end{algorithmic}
\end{algorithmhere}

%\begin{algorithm}[H]
%\caption{Mittelpunkt}\label{alg:Mittelpunkt}
%\begin{algorithmic}
%\Function{Mittelpunkt}{$s$}
%	\State \textbf{Ergebnis} $\frac{\textproc{Start}(s) + \textproc{Ende}(s)}{2}$
%\EndFunction
%\end{algorithmic}
%\end{algorithm}


\subsection{Punktezuordnung}
\label{ch:correlation-algorithm}

%7. Punktzuordnungen erzeugen (Vorstufe Generalisierung)
%
%- ∀ Segmente "S" : S hat Parallele und S noch nicht "fertig 7"
%    - ∀ Punkte (Start/End "T₁"), ∀ Seiten von S (L/R) "A"
%        - ∀ Parallelen von S "P" auf Seite A
%            - nahegelehensten Punkt finden "T₂"
%            - falls nichts gefunden (= keine Parallele auf dieser Seite), näcshtes A
%            - neue Punktzuordung: T₁ ↔︎ T₂
%    - S markieren als "fertig 7"
%
%_defer:_
%- ∀ Parallelen von S: Rekursion
%- alle Segmente/Zuordnungen für je ein ursprüngliches Segment als Teil eines "Blocks" markieren (könnte später evtl. Auffinden eines Anfangs zur Generalisierung erleichtern)

Das Zusammenfassen einander paralleler Segmente soll durch Zusammenfassen ihrer Start- und Endpunkte erfolgen.
Hierzu müssen zunächst die \term{nodes} der zusammenzufassenden Segmente einander zugeordnet werden.
% (wegen der Weiterschaltung...)
Dies geschieht auf Basis der durch die \textproc{Analyse} ermittelten Kennzeichnungen der Segmente als parallel.

Der Algorithmus \textproc{NodesZuordnen} sucht für jeden \term{node} beidseitig den jeweils am nächsten gelegenen \term{node} der als parallel gekennzeichneten Segmente (Abbildung~\ref{fig:node-correlation}).

\begin{algorithmhere}{Nodes Zuordnen}
\label{alg:Zuordnen}
\begin{algorithmic}
\Function{NodesZuordnen}{$S$}
	\State $C \gets \varnothing$
	\ForAll{$s \textbf{ mit } s \in S$}
		\ForAll{$t \textbf{ mit } t \in \{parallelLinks(s), parallelRechts(s)\}$}
			\ForAll{$n_1 \textbf{ mit } n_1 \in \{\textproc{Start}(s), \textproc{Ende}(s)\} $}
				\State $n_2 \gets \begin{cases}\textproc{Start}(t) & \text{für } \abs n_1 - \textproc{Start}(t)\abs < \abs n_1 - \textproc{Ende}(t)\abs\\\textproc{Ende}(t) & \text{sonst}\end{cases}$
%				\State $C \gets \{(n_1, n_2)\} \cup C \setminus \{(n_2, n_1)\}$\Comment{entgegengesetzte Kanten ausschließen}
				\State $C \gets C \cup \{\{n_1, n_2\}\}$
			\EndFor
		\EndFor
	\EndFor
	\State \textbf{Ergebnis} $C$
\EndFunction
\end{algorithmic}
\end{algorithmhere}

%Die Zuordnungen werden hier als gerichtete Kante $(n_1, n_2)$ beschrieben, obwohl die Orientierung keine Rolle spielt.
%Dies vereinfacht die weitere Verarbeitung.
%Allerdings müssen entgegengesetzte Kanten $(n_1, n_2)$ ausgeschlossen werden, um doppelte \term{nodes} im Generalisierungsergebnis zu vermeiden.

Weil die Orientierung der Zuordnungen keine Rolle spielt, wird hier mit $\{n_1, n_2\}$ ein \emph{ungeordnetes} Paar beschrieben.
Dies vermeidet Duplikate.
% Ergebnis: Abb. 29 general-approach

\onefigure{ht}{
	\includegraphics[width=\ScaleIfNeeded]{../chapter4/node-correlation}
	\caption{Zuordnung gegenüberliegender \term{nodes} paralleler Linienzüge}
	\label{fig:node-correlation}
}


\subsection{Parallelen zusammenfassen}
\label{ch:generalisation-algorithm}

%8. Generalisierung
%
%"trivialer Fall":
%1. zufällig Segment S wählen, Edge E (ES, ET) (Bedingung: Zähler E < 2)
%2. Richtung D zufällig wählen (-> S); {F,R}
%    1. gegenüberliegendes Segment T (für Start): dasjenige der beiden (<- trivialer Fall) Segment von ET, welches -- so gedreht, dass der Start-Node == ES ist -- in die gleiche Richtung zeigt wie S
%3. ∀ D :
%    1. wiederhole, solange ∃ E
%4. M-Punkt setzen
%    5. Segmente A,B von E in Richtung D: nächste Nodes N {X,Y} finden (falls ∄: N:= aktueller Node
%    6. ∀ N:
%        7. Edge F von N zurück zu E? (X->ET, Y->ES)
%           ∃: F ist nächstes E; Zähler E + 1, Zähler F + 1
%           ∄: continue 6, sonst: Edge F(X,Y)
%              ∃: F ist nächstes E
%      E=F <=> ∄: Zähler E + 1, continue 3

Anhand der Punktezuordnungen können die parallelen Segmente nun zusammengefasst werden.
Hierzu wird ein zufällig ausgewähltes Segment als Beginn eines Linienzugs betrachtet.
Während diesem Linienzug von Segment zu Segment gefolgt wird, können anhand der Punktzuordnungen leicht die Stützpunkte der Mittellinie zwischen den Parallelen als Generalisierungsergebnis bestimmt werden.

\begin{algorithmhere}{Zusammenfassen}
\label{alg:Zusammenfassen}
\begin{algorithmic}
\Function{Zusammenfassen}{$S, C$}\Comment{Segmente $S$, Punktezuordnungen $C$}
	\State generalisierter Graph $\mathcal{G} \gets$ leer
	\ForAll{Segmente $s$, die noch nicht als zusammengefasst markiert sind}
		\ForAll{Zuordnungen $c$, die mit dem Start-Node $n$ von $s$ verknüpft sind}
			\State zusammengefasster Linienzug $L \gets$ leer
			\State $t \gets$ mit dem jeweils anderem Node von $c$ verknüpftes Segment,\\\qquad\qquad\qquad\quad$\hookrightarrow$ welches von $n$ aus gesehen in die gleiche Richtung zeigt wie $s$
			\While{es eine nächste Zuordnung $c'$ in dieser Richtung gibt,\\\qquad\qquad\qquad\qquad$\hookrightarrow$ die $s$ und $t$ ebenfalls einander zuordnet}
				\State $m \gets$ Mittelpunkt von $c$
				\State $m' \gets$ Mittelpunkt von $c'$
				\State füge Segment $(m, m')$ zu $L$ hinzu
				\State $s' \gets$ Segment, das $s$ nach $c'$ fortführt
				\If{$s \neq s'$}
					\State markiere $s$ als zusammengefasst
					\State $s \gets s'$
				\EndIf
				\State $t' \gets$ Segment, das $t$ nach $c'$ fortführt
				\If{$t \neq t'$}
					\State markiere $t$ als zusammengefasst
					\State $t \gets t'$
				\EndIf
				\State $c \gets c'$
			\EndWhile
			\State füge $L$ zu $\mathcal{G}$ hinzu
		\EndFor
	\EndFor
	\State füge alle nicht zusammengefassten Segmente zu $\mathcal{G}$ hinzu
	\State \textbf{Ergebnis} $\mathcal{G}$
\EndFunction
\end{algorithmic}
\end{algorithmhere}

Diese Beschreibung des Algorithmus zum \textproc{Zusammenfassen} berücksichtigt
%der Übersichtlichkeit halber
weder Kreuzungen noch den Übergang eines einzelnen Linienzugs in zwei parallele Linienzüge.

Auch der Fall von mehr als zwei Parallelen bleibt unberücksichtigt.
Dies muss bei der Implementierung bedacht werden, da der Begriff „als zusammengefasst markiert“ sonst nicht eindeutig ist.
Der hier beschriebene Algorithmus fasst dann $n$ parallele Linienzüge zu $n-1$ parallelen Linienzügen zusammen, die jeweils mittig zwischen zwei Parallelen in den Ausgangsdaten liegen.
Eine Erweiterung zur Zusammenfassung einer beliebigen Anzahl von Parallelen auf genau einen Linienzug ist über die Punktezuordnungen möglich, was jedoch in dieser Arbeit nicht weiter betrachtet wird.

Je nach Anwendungsfall sind Nachbearbeitungen und weitere Generalisierungsvorgänge sinnvoll.
In Frage kommen insbesondere die Verknüpfung von aneinander anschließenden Linienzügen sowie eine Formvereinfachung.

% Weiterschaltung ist notwendig, weil ansonsten Endpunkte der generalisierten Linie nicht unbedingt aneinander anstoßen (durch Bildung von "Dreiecken" im Zuordnungsgraphen überlappen sich die Mittellinien u. U.)

% TODO: Grafik wäre hier keine schlechte Ergänzung


% mit vorwärts/rückwärts-Logik (nur sinnvoll, wenn man das Verketten für Wesentlich hält, was das Themenblatt nicht tut ("Verkettung, soweit zum Zusammenfassen nötig")
%\begin{algorithm}[H]
%\caption{Zusammenfassen}\label{alg:Zusammenfassen}
%\begin{algorithmic}
%\Function{Zusammenfassen}{$S, C$}
%	\State generalisierter Graph $\mathcal{G} \gets$ leer
%	\ForAll{Segmente $s$, die noch nicht als zusammengefasst markiert sind}
%		\ForAll{Zuordnungen $e$, die mit dem Start-Node $n$ von $s$ verknüpft sind}
%			\State zusammengefasster Linienzug $L \gets$ leer
%			\State $t \gets$ mit dem jeweils anderem Node von $e$ verknüpftes Segment, welches von $n$ aus gesehen in die gleiche Richtung zeigt wie $s$
%			\While{es eine nächste Zuordnung $f$ gibt, die $s$ und $t$ an deren anderen Ende ebenfalls einander zuordnet}
%				\State $m \gets$ Mittelpunkt von $e$
%				\State $m' \gets$ Mittelpunkt von $f$
%				\State füge Segment $(m, m')$ am Ende von $L$ hinzu
%				\State markiere $s$ und $t$ als zusammengefasst
%				\State $s \gets$ Segment, das $s$ nach $f$ fortführt
%				\State $t \gets$ Segment, das $t$ nach $f$ fortführt
%			\EndWhile
%			\State $s \gets$ Segment, das $s$ in die Gegenrichtung fortführt
%			\State $t \gets$ mit dem jeweils anderem Node von $e$ verknüpftes Segment, welches von $n$ aus gesehen in die gleiche Richtung zeigt wie $s$
%			\While{es eine nächste Zuordnung $f$ gibt, die $s$ und $t$ an deren anderen Ende ebenfalls einander zuordnet}
%				\State $m \gets$ Mittelpunkt von $e$
%				\State $m' \gets$ Mittelpunkt von $f$
%				\State füge Segment $(m, m')$ am Anfang von $L$ hinzu
%				\State markiere $s$ und $t$ als zusammengefasst
%				\State $s \gets$ Segment, das $s$ nach $f$ fortführt
%				\State $t \gets$ Segment, das $t$ nach $f$ fortführt
%			\EndWhile
%			\State füge $L$ zu $\mathcal{G}$ hinzu
%		\EndFor
%	\EndFor
%	\State füge alle nicht zusammengefassten Segmente zu $\mathcal{G}$ hinzu
%	\State \textbf{Ergebnis} $\mathcal{G}$
%\EndFunction
%\end{algorithmic}
%\end{algorithm}

% Versuche mit Formelsatz
%\begin{algorithm}[H]
%\caption{Zusammenfassen}\label{alg:Zusammenfassen}
%%$\textbf{Variable } zusammengefasst : Segment \rightarrow bool$
%%\\$\textbf{Anfangswert } zusammengefasst(a) \stackrel{\text{\tiny def}}{=} nein$ $\forall$ $a$
%% \neg$ $zusammengefasst(s)
%\begin{algorithmic}
%\Function{Zusammenfassen}{$S, C$}
%	\ForAll{$s \textbf{ mit } s \in S, s =: (n_1, n_2)$}
%		\ForAll{$e \textbf{ mit } e \in C, e =: (e_1, e_2) \wedge (e_1 = n_1 \vee e_2 = n_1)$}
%			\State $T \gets \{t : t \in S, t =: (n_3, n_4) \wedge |\{e_1, e_2, n_3, n_4\}| < 4\}$
%			% T <- alle Segmente von ET
%			\ForAll{$t \textbf{ mit } t \in T, t =: (n_3, n_4)$}
%				
%				\State $ $ % hierhin jetzt die "cases" für die Drehung/Unterscheidung, damit bei 2.->1. das richtige ES/ET kommt
%			% ^--- "in die gleiche Richtung zeigt wie S" - wie ist das gemeint?
%				
%				
%			\EndFor
%		\EndFor
%	\EndFor
%	
%	
%%	\State $C \gets \varnothing$
%%	\ForAll{$s \textbf{ mit } s \in S, s =: (n_1, n_2)$}% \wedge \neg$ $fertig7(t)$}
%%		\ForAll{$t \textbf{ mit } t \in \{parallelLinks(s), parallelRechts(s)\}, t =: (n_3, n_4)$}
%%			\ForAll{$e_1 \textbf{ mit } e_1 \in \{n_1, n_2\} $}
%%				\State $e_2 \gets \begin{cases}n_3 & \text{für } ||e_1 - n_3|| \textless ||e_1 - n_4||\\n_4 & \text{sonst}\end{cases}$
%%				\State $C \gets C \cup (e_1, e_2)$\Comment{$e_2$ ist der $e_1$ am nächsten gelegene \term{node} von $t$}
%%			\EndFor
%%		\EndFor
%%%		\State $fertig7(s) \gets ja$
%%	\EndFor
%%	\State \textbf{Ergebnis} $C$
%\EndFunction
%\end{algorithmic}
%\end{algorithm}


\section{Gesamtüberblick}

\begin{algorithmhere}{Generalisierung}
\label{alg:Generalisierung}
\begin{algorithmic}
\Function{Generalisierung}{$W$}
	\State $S \gets \textproc{Segmente}(W)$
	\State $S' \gets \textproc{Splitten}(S)$\Comment{Abschnitt~\ref{ch:split-algorithm}}
	\State $\textproc{Analyse}(S')$\Comment{Abschnitt~\ref{ch:analyse-algorithm}}
	\State $C \gets \textproc{NodesZuordnen}(S)$\Comment{Abschnitt~\ref{ch:correlation-algorithm}}
	\State $\mathcal{G} \gets \textproc{Zusammenfassen}(S, C)$\Comment{Abschnitt~\ref{ch:generalisation-algorithm}}
	\State \textbf{Ergebnis} $\mathcal{G}$
\EndFunction
\end{algorithmic}
\end{algorithmhere}

% TODO: Algorithmus-Eigenschaften beschreiben:
% - korrekt: nicht definiert, also nicht nachweisbar, Nachweis würde auch den Rahmen sprengen (aber anschaulich klar und später zu prüfen)
% - terminierend: ja, weil alle Schleifen auf abschließenden Mengen arbeiten, mit Ausnahme des Splittens, wobei aber durch die minimale Fragmentlänge µ eine klare Abbruchbedingung gegeben ist
% - deterministisch: nein; erstens abhängig von Input denkbar, dass je nach Reihenfolge der Iteration das Splitten und damit die Analyse unterschiedliche Ergebnisse liefert; zweitens Länge der generalisierten Linienzüge zufallsabhängig (da "rückwärts" nicht spezifiziert); jedoch nicht zu erwarten, dass diese Varianzen großen Einfluss auf das Ergebnis haben
% - Effizienz: evtl. grobe Landau-Betrachtung, bezogen auf ||W||, genaueres weiter hinten

% TODO: Analyse-Ergebnis beschreiben



%\section{alte Einteilung}
%
%\subsection{Identifikation parallel verlaufender Linien-Fragmente}
%
%Ansatz: Dieser Algorithmus eignet sich insgesamt weniger gut zur Identifikation als zur Generalisierung.
%Die Identifikation erfolgt, indem festgestellt wird, ob eine Generalisierung notwendig ist oder nicht; falls sie notwendig ist, kann sie dann aber auch bereits recht billig durchgeführt werden.
%Andererseits ist fraglich, welchen "praxistauglichen" Einsatz eine reine Identifikation ohne anschließende Generalisierung hätte.
%
%Konzept (abstrakt):
%
%1. nur Segmente betrachten (gerade Linienabschnitte, definiert durch zwei Punkte)
%
%2. alle nahe beieinander liegenden Segmente auf Parallelität untersuchen
%
%Die Segmente sind jedoch unterschiedlich lang und liegen teilweise etwas „verstreut“ im Raum, was die Untersuchung erschwert.
%Deshalb werden die Segmente zunächst fragmentiert, indem benachbarte Segmente „geschickt“ weiter in kürzere Segmente unterteilt werden, so dass parallele Segmente immer ähnlich lang sind und einander gegenüberstehen.
%
%Im Detail:
%
%1. geometrische Indizierung (R-Tree) der Eingabedaten, um Suche nach nahen LineParts zu ermöglichen [regionalise]
%
%2. $\forall$ LineParts: AbstractLinePart.splitCloseParallels, um gut vergleichbare Stücke zu erhalten (reentrant/rekursiv, d. h. neu erzeugte Fragmente werden bis zu einer Mindestgröße immer weiter aufgeteilt) [split]
%
%3. $\forall$ LineParts: $\forall$ nahe Parallelen (laut Index): [analyse]
%
%3.1 Vorprüfung (boolean)
%
%3.2 Hauptprüfung (double)
%
%3.3 best matches (links/rechts getrennt) speichern (keine Nachprüfung => falls das best match nicht passt, wird es trotzdem genommen, sofern nicht schon die vorprüfung die sache abgebrochen hat)
%% offen: "realParallels"-Konzept
%% geprüft werden die Fragmente, gespeichert werden die Segmente
%
%% graphisch erklären, was genau passiert
%
%
%\subsection{Generalisierung durch Zusammenfassung}
%
%Konzept (in den allgemeinsten Begriffen):
%
%1. Endpunkte der parallelen Segmente einander zuordnen
%
%2. Der gesamte Graph wird "durchgehangelt", indem von einer CorrelationEdge ausgehend immer entlang der Segmente das nächste CorrelationEdge gefunden wird; diese Edges werden dann durch neu erzeugte Mittelpunkte miteinander verbunden.
%
%
%
%% (Der CorrelationGraph ist ein Graph, in dem CorrelationEdges einander gegenüberliegende Knoten von parallelen Segmenten verbinden.)
%
%% new GeneralisedLines
%% - beliebige CorrelationEdge auswählen und von ihr ausgehend den angrenzenden Segmenten erst in die eine, dann die andere Richtung folgen, bis das Folgen nicht mehr eindeutig möglich ist (z. B. wegen einer Abzweigung)
%% - dabei Mittelpunkte der CorrelationEdges jeweils einer neuen GeneralisedSection hinzufügen
%% - Segmente, die nicht zusammengefasst wurden (weil keine Parallelen existieren), werden in Sections umgewandelt und ebenfalls den GeneralisedLines hinzugefügt, um einen homogenen Ergebnisdatensatz zu erhalten
%
%...
%
%
%\subsection{Verknüpfung von Linienfragmenten zu einem einzigen kontinuierlichen Linienzug}
%
%...


% single-chapter commands
\onlyinsubfile{\listoffigures}
%\onlyinsubfile{\listoftables}
%\onlyinsubfile{\input{../bibliography}}
\end{document}
